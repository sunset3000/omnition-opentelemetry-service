// Copyright 2019 OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: omnitelk.proto

/*
Package omnitelk is a generated protocol buffer package.

It is generated from these files:
	omnitelk.proto

It has these top-level messages:
	ExportRequest
	EncodedRecord
	ExportResponse
	ShardDefinition
	ShardingConfig
	ConfigRequest
*/
package omnitelk

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ExportResponse_ResultCode int32

const (
	// Successfully received and accepted.
	ExportResponse_SUCCESS ExportResponse_ResultCode = 0
	// Failed to process the data. Sender MUST NOT retry this request.
	ExportResponse_FAILED_NOT_RETRYABLE ExportResponse_ResultCode = 1
	// Failed to process the data. Sender SHOULD retry this request.
	ExportResponse_FAILED_RETRYABLE ExportResponse_ResultCode = 2
	// Sharding configuration at receiver does not match
	// sharding performed by sender. Sender MUST re-shard the
	// data according to new sharding configuration specified
	// in shardingConfig field and send again.
	ExportResponse_SHARD_CONFIG_MISTMATCH ExportResponse_ResultCode = 3
)

var ExportResponse_ResultCode_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILED_NOT_RETRYABLE",
	2: "FAILED_RETRYABLE",
	3: "SHARD_CONFIG_MISTMATCH",
}
var ExportResponse_ResultCode_value = map[string]int32{
	"SUCCESS":                0,
	"FAILED_NOT_RETRYABLE":   1,
	"FAILED_RETRYABLE":       2,
	"SHARD_CONFIG_MISTMATCH": 3,
}

func (x ExportResponse_ResultCode) String() string {
	return proto.EnumName(ExportResponse_ResultCode_name, int32(x))
}
func (ExportResponse_ResultCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type ExportRequest struct {
	// Unique request id.
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// List of encoded records.
	Records []*EncodedRecord `protobuf:"bytes,2,rep,name=records" json:"records,omitempty"`
	// The shard that the records were prepared for. The receiver will
	// accept the records if the current sharding configuration has a
	// shard with specified shardId and matching hash key range.
	Shard *ShardDefinition `protobuf:"bytes,3,opt,name=shard" json:"shard,omitempty"`
}

func (m *ExportRequest) Reset()                    { *m = ExportRequest{} }
func (m *ExportRequest) String() string            { return proto.CompactTextString(m) }
func (*ExportRequest) ProtoMessage()               {}
func (*ExportRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ExportRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ExportRequest) GetRecords() []*EncodedRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

func (m *ExportRequest) GetShard() *ShardDefinition {
	if m != nil {
		return m.Shard
	}
	return nil
}

type EncodedRecord struct {
	// data is a byte sequence encoded as follows:
	// 1. github.com/omnition/opencensus-go-exporter-kinesis/SpanList
	//    encoded in Protocol Buffer format.
	// 2. Result of step 1 compressed using gzip.
	Data []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	// Partition key defines the shard that this data is intended for.
	PartitionKey string `protobuf:"bytes,3,opt,name=partitionKey" json:"partitionKey,omitempty"`
}

func (m *EncodedRecord) Reset()                    { *m = EncodedRecord{} }
func (m *EncodedRecord) String() string            { return proto.CompactTextString(m) }
func (*EncodedRecord) ProtoMessage()               {}
func (*EncodedRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EncodedRecord) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *EncodedRecord) GetPartitionKey() string {
	if m != nil {
		return m.PartitionKey
	}
	return ""
}

type ExportResponse struct {
	// Request id to which this response corresponds.
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Result of request processing.
	ResultCode ExportResponse_ResultCode `protobuf:"varint,2,opt,name=resultCode,enum=omnitelk.ExportResponse_ResultCode" json:"resultCode,omitempty"`
	// If resultCode=SHARD_CONFIG_MISTMATCH then this field
	// must contain the new sharding configuration otherwise
	// it should be omitted and ignored.
	ShardingConfig *ShardingConfig `protobuf:"bytes,3,opt,name=shardingConfig" json:"shardingConfig,omitempty"`
}

func (m *ExportResponse) Reset()                    { *m = ExportResponse{} }
func (m *ExportResponse) String() string            { return proto.CompactTextString(m) }
func (*ExportResponse) ProtoMessage()               {}
func (*ExportResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ExportResponse) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ExportResponse) GetResultCode() ExportResponse_ResultCode {
	if m != nil {
		return m.ResultCode
	}
	return ExportResponse_SUCCESS
}

func (m *ExportResponse) GetShardingConfig() *ShardingConfig {
	if m != nil {
		return m.ShardingConfig
	}
	return nil
}

type ShardDefinition struct {
	// The id of the shard.
	ShardId []byte `protobuf:"bytes,1,opt,name=shardId,proto3" json:"shardId,omitempty"`
	// Shard starting and ending hash keys.
	// hasKey is byte sequence representation of big.Int hash key.
	StartingHashKey []byte `protobuf:"bytes,2,opt,name=startingHashKey,proto3" json:"startingHashKey,omitempty"`
	EndingHashKey   []byte `protobuf:"bytes,3,opt,name=endingHashKey,proto3" json:"endingHashKey,omitempty"`
}

func (m *ShardDefinition) Reset()                    { *m = ShardDefinition{} }
func (m *ShardDefinition) String() string            { return proto.CompactTextString(m) }
func (*ShardDefinition) ProtoMessage()               {}
func (*ShardDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ShardDefinition) GetShardId() []byte {
	if m != nil {
		return m.ShardId
	}
	return nil
}

func (m *ShardDefinition) GetStartingHashKey() []byte {
	if m != nil {
		return m.StartingHashKey
	}
	return nil
}

func (m *ShardDefinition) GetEndingHashKey() []byte {
	if m != nil {
		return m.EndingHashKey
	}
	return nil
}

type ShardingConfig struct {
	// Sharding configuration is a list of shard definitions.
	ShardDefinitions []*ShardDefinition `protobuf:"bytes,1,rep,name=shardDefinitions" json:"shardDefinitions,omitempty"`
}

func (m *ShardingConfig) Reset()                    { *m = ShardingConfig{} }
func (m *ShardingConfig) String() string            { return proto.CompactTextString(m) }
func (*ShardingConfig) ProtoMessage()               {}
func (*ShardingConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ShardingConfig) GetShardDefinitions() []*ShardDefinition {
	if m != nil {
		return m.ShardDefinitions
	}
	return nil
}

type ConfigRequest struct {
}

func (m *ConfigRequest) Reset()                    { *m = ConfigRequest{} }
func (m *ConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*ConfigRequest) ProtoMessage()               {}
func (*ConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func init() {
	proto.RegisterType((*ExportRequest)(nil), "omnitelk.ExportRequest")
	proto.RegisterType((*EncodedRecord)(nil), "omnitelk.EncodedRecord")
	proto.RegisterType((*ExportResponse)(nil), "omnitelk.ExportResponse")
	proto.RegisterType((*ShardDefinition)(nil), "omnitelk.ShardDefinition")
	proto.RegisterType((*ShardingConfig)(nil), "omnitelk.ShardingConfig")
	proto.RegisterType((*ConfigRequest)(nil), "omnitelk.ConfigRequest")
	proto.RegisterEnum("omnitelk.ExportResponse_ResultCode", ExportResponse_ResultCode_name, ExportResponse_ResultCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for OmnitelK service

type OmnitelKClient interface {
	// Get the sharding configuration. Typically called at the beginning of
	// communication, before calling Export.
	GetShardingConfig(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*ShardingConfig, error)
	// Export a stream of requests and receive a stream of responses.
	Export(ctx context.Context, opts ...grpc.CallOption) (OmnitelK_ExportClient, error)
}

type omnitelKClient struct {
	cc *grpc.ClientConn
}

func NewOmnitelKClient(cc *grpc.ClientConn) OmnitelKClient {
	return &omnitelKClient{cc}
}

func (c *omnitelKClient) GetShardingConfig(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*ShardingConfig, error) {
	out := new(ShardingConfig)
	err := grpc.Invoke(ctx, "/omnitelk.OmnitelK/GetShardingConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *omnitelKClient) Export(ctx context.Context, opts ...grpc.CallOption) (OmnitelK_ExportClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OmnitelK_serviceDesc.Streams[0], c.cc, "/omnitelk.OmnitelK/Export", opts...)
	if err != nil {
		return nil, err
	}
	x := &omnitelKExportClient{stream}
	return x, nil
}

type OmnitelK_ExportClient interface {
	Send(*ExportRequest) error
	Recv() (*ExportResponse, error)
	grpc.ClientStream
}

type omnitelKExportClient struct {
	grpc.ClientStream
}

func (x *omnitelKExportClient) Send(m *ExportRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *omnitelKExportClient) Recv() (*ExportResponse, error) {
	m := new(ExportResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for OmnitelK service

type OmnitelKServer interface {
	// Get the sharding configuration. Typically called at the beginning of
	// communication, before calling Export.
	GetShardingConfig(context.Context, *ConfigRequest) (*ShardingConfig, error)
	// Export a stream of requests and receive a stream of responses.
	Export(OmnitelK_ExportServer) error
}

func RegisterOmnitelKServer(s *grpc.Server, srv OmnitelKServer) {
	s.RegisterService(&_OmnitelK_serviceDesc, srv)
}

func _OmnitelK_GetShardingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OmnitelKServer).GetShardingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/omnitelk.OmnitelK/GetShardingConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OmnitelKServer).GetShardingConfig(ctx, req.(*ConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OmnitelK_Export_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OmnitelKServer).Export(&omnitelKExportServer{stream})
}

type OmnitelK_ExportServer interface {
	Send(*ExportResponse) error
	Recv() (*ExportRequest, error)
	grpc.ServerStream
}

type omnitelKExportServer struct {
	grpc.ServerStream
}

func (x *omnitelKExportServer) Send(m *ExportResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *omnitelKExportServer) Recv() (*ExportRequest, error) {
	m := new(ExportRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _OmnitelK_serviceDesc = grpc.ServiceDesc{
	ServiceName: "omnitelk.OmnitelK",
	HandlerType: (*OmnitelKServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetShardingConfig",
			Handler:    _OmnitelK_GetShardingConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Export",
			Handler:       _OmnitelK_Export_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "omnitelk.proto",
}

func init() { proto.RegisterFile("omnitelk.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 457 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x53, 0x4d, 0x8f, 0xd3, 0x30,
	0x10, 0xad, 0xd3, 0xb2, 0x5d, 0xa6, 0x6d, 0x5a, 0x46, 0x2b, 0x08, 0x7b, 0x8a, 0x0c, 0x87, 0x9c,
	0x0a, 0x94, 0x3f, 0x40, 0x48, 0xb3, 0x6d, 0xb5, 0x1f, 0x95, 0x9c, 0x22, 0xc4, 0xa9, 0x0a, 0x1b,
	0x6f, 0x37, 0x62, 0xb1, 0x4b, 0xec, 0x95, 0x40, 0x1c, 0xb9, 0x73, 0xe5, 0xef, 0xa2, 0x3a, 0xfd,
	0x88, 0xb3, 0x82, 0x5b, 0x3c, 0xf3, 0xde, 0x64, 0xde, 0xf3, 0x33, 0xb8, 0xf2, 0xab, 0xc8, 0x35,
	0xbf, 0xfb, 0x32, 0x5c, 0x17, 0x52, 0x4b, 0x3c, 0xde, 0x9d, 0xe9, 0x2f, 0x02, 0xbd, 0xf8, 0xfb,
	0x5a, 0x16, 0x9a, 0xf1, 0x6f, 0xf7, 0x5c, 0x69, 0x74, 0xc1, 0xc9, 0x33, 0x8f, 0xf8, 0x24, 0x68,
	0x31, 0x27, 0xcf, 0xf0, 0x0d, 0xb4, 0x0b, 0x7e, 0x2d, 0x8b, 0x4c, 0x79, 0x8e, 0xdf, 0x0c, 0x3a,
	0xa3, 0x67, 0xc3, 0xfd, 0xb4, 0x58, 0x5c, 0xcb, 0x8c, 0x67, 0xcc, 0xf4, 0xd9, 0x0e, 0x87, 0xaf,
	0xe0, 0x91, 0xba, 0x4d, 0x8b, 0xcc, 0x6b, 0xfa, 0x24, 0xe8, 0x8c, 0x9e, 0x1f, 0x08, 0xc9, 0xa6,
	0x3c, 0xe6, 0x37, 0xb9, 0xc8, 0x75, 0x2e, 0x05, 0x2b, 0x71, 0x74, 0x02, 0x3d, 0x6b, 0x14, 0x22,
	0xb4, 0xb2, 0x54, 0xa7, 0x5e, 0xcb, 0x27, 0x41, 0x97, 0x99, 0x6f, 0xa4, 0xd0, 0x5d, 0xa7, 0x85,
	0x36, 0xc4, 0x73, 0xfe, 0xc3, 0x0c, 0x7f, 0xcc, 0xac, 0x1a, 0xfd, 0xed, 0x80, 0xbb, 0x93, 0xa3,
	0xd6, 0x52, 0x28, 0xfe, 0x40, 0x4f, 0x04, 0x50, 0x70, 0x75, 0x7f, 0xa7, 0x23, 0x99, 0x71, 0xcf,
	0xf1, 0x49, 0xe0, 0x8e, 0x5e, 0x54, 0x24, 0x59, 0xec, 0x21, 0xdb, 0x43, 0x59, 0x85, 0x86, 0xef,
	0xc0, 0x35, 0x9b, 0xe7, 0x62, 0x15, 0x49, 0x71, 0x93, 0xaf, 0xb6, 0x52, 0xbd, 0x9a, 0xd4, 0x7d,
	0x9f, 0xd5, 0xf0, 0x94, 0x03, 0x1c, 0x66, 0x63, 0x07, 0xda, 0xc9, 0x87, 0x28, 0x8a, 0x93, 0x64,
	0xd0, 0x40, 0x0f, 0x4e, 0xce, 0xc2, 0xd9, 0x45, 0x3c, 0x5e, 0x5e, 0xcd, 0x17, 0x4b, 0x16, 0x2f,
	0xd8, 0xa7, 0xf0, 0xfd, 0x45, 0x3c, 0x20, 0x78, 0x02, 0x83, 0x6d, 0xe7, 0x50, 0x75, 0xf0, 0x14,
	0x9e, 0x26, 0xd3, 0x90, 0x8d, 0x97, 0xd1, 0xfc, 0xea, 0x6c, 0x36, 0x59, 0x5e, 0xce, 0x92, 0xc5,
	0x65, 0xb8, 0x88, 0xa6, 0x83, 0x26, 0xfd, 0x09, 0xfd, 0x9a, 0xe7, 0xe8, 0x41, 0xdb, 0xec, 0x32,
	0x2b, 0x5d, 0xe9, 0xb2, 0xdd, 0x11, 0x03, 0xe8, 0x2b, 0xbd, 0xb1, 0x53, 0xac, 0xa6, 0xa9, 0xba,
	0xdd, 0x98, 0xec, 0x18, 0x44, 0xbd, 0x8c, 0x2f, 0xa1, 0xc7, 0x45, 0x56, 0xc1, 0x35, 0x0d, 0xce,
	0x2e, 0xd2, 0x8f, 0xe0, 0xda, 0x2e, 0x60, 0x0c, 0x03, 0x65, 0xaf, 0xa3, 0x3c, 0x62, 0x52, 0xf5,
	0x9f, 0x90, 0x3c, 0xa0, 0xd0, 0x3e, 0xf4, 0xb6, 0xb6, 0x96, 0xa1, 0x1d, 0xfd, 0x21, 0x70, 0x3c,
	0x2f, 0xf9, 0xe7, 0x38, 0x85, 0x27, 0x13, 0xae, 0x6b, 0x7f, 0xae, 0xa4, 0xd6, 0xa2, 0x9e, 0xfe,
	0xf3, 0xca, 0x68, 0x03, 0x43, 0x38, 0x2a, 0xf3, 0x50, 0xa5, 0x5b, 0xcf, 0xa5, 0x4a, 0xb7, 0xa3,
	0x43, 0x1b, 0x01, 0x79, 0x4d, 0x3e, 0x1f, 0x99, 0x17, 0xf7, 0xf6, 0x6f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xc8, 0x31, 0x13, 0x5e, 0x83, 0x03, 0x00, 0x00,
}
